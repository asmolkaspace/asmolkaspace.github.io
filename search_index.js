var documenterSearchIndex = {"docs":
[{"location":"exospheres/coriolis.html#Coriolis","page":"Coriolis","title":"Coriolis","text":"","category":"section"},{"location":"exospheres/coriolis.html","page":"Coriolis","title":"Coriolis","text":"For many applications on extraterrestrial bodies, the rotation of the body is changing the velocities and landing coordinates.","category":"page"},{"location":"exospheres/coriolis.html#Manual","page":"Coriolis","title":"Manual","text":"","category":"section"},{"location":"exospheres/coriolis.html","page":"Coriolis","title":"Coriolis","text":"The coriolis functions ","category":"page"},{"location":"exospheres/coriolis.html","page":"Coriolis","title":"Coriolis","text":"# load and use ExESS package\ninclude(joinpath(PATH_TO_PKG, \"src\", \"ExESS.jl\"))\nusing .ExESS\n\n# variable setup\nP = LUNAR_DAY       # rotational period of the Moon in seconds\nt = 100             # flight duration in seconds\nr = LUNAR_RADIUS    # mean radius of the Moon in meter\n\n# coriolis functions\ncoriolis_longitude(t, P)\ncoriolis_velocity(r, P)","category":"page"},{"location":"exospheres/coriolis.html#Examples","page":"Coriolis","title":"Examples","text":"","category":"section"},{"location":"exospheres/coriolis.html#API","page":"Coriolis","title":"API","text":"","category":"section"},{"location":"exospheres/coriolis.html","page":"Coriolis","title":"Coriolis","text":"coriolis_longitude\ncoriolis_velocity\nrotational_velocity","category":"page"},{"location":"exospheres/coriolis.html#Main.ExESS.coriolis_longitude","page":"Coriolis","title":"Main.ExESS.coriolis_longitude","text":"[1] coriolis_longitude(t::Real, P::Real)::Float32\n\nCalculates the longitudinal shift due to the rotation of a body, based on the passed time  t and the rotational period P.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/coriolis.html#Main.ExESS.coriolis_velocity","page":"Coriolis","title":"Main.ExESS.coriolis_velocity","text":"[1] coriolis_velocity(r::Real, P::Real)::Vector{Float32}\n[2] coriolis_velocity(r::Real, P::Real, lat::Real)::Vector{Float32}\n\nCalculates the velocity vector resulting from the coriolis effect.\n\n\n\n[1] Based on the radius to the center of rotation r and the rotational period P.\n\n\n\n[2] Based on the radius of the sphere r, the latitude from the equator (plane of  rotation) lat, and the rotational period P.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/coriolis.html#Main.ExESS.rotational_velocity","page":"Coriolis","title":"Main.ExESS.rotational_velocity","text":"[1] rotational_velocity(r::Real, P::Real)::Float32\n[2] rotational_velocity(r::Real, P::Real, lat::Real)::Float32\n\nCalculates the rotational velocity.\n\n\n\n[1] Based on the radius to the center of rotation r and the rotational period P.\n\n\n\n[2] Based on the radius of the sphere r, the latitude from the equator (plane of  rotation) lat, and the rotational period P.\n\n\n\n\n\n","category":"function"},{"location":"surfaces/solar_angle.html#Solar-Angle","page":"Solar Angles","title":"Solar Angle","text":"","category":"section"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"For many processes regarding the surface of the extraterrestrial body, the incidence angle of the sunlight is an important factor. ","category":"page"},{"location":"surfaces/solar_angle.html#Manual","page":"Solar Angles","title":"Manual","text":"","category":"section"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"Without any knowledge about the topology, the function solar_angle assumes that the body is a perfect sphere and that the angle between the surface normal at a certain position given as a subsolar longitude theta and latitude phi can be calculated as","category":"page"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"alpha = cos^-1 left( cos(theta) cdot cos(phi) right)","category":"page"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"Note that both angular arguments must be given in radians, with the results also being returned in radians.","category":"page"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"lng = rand()*2*pi - pi\nlat = rand()*pi - pi/2\nsolar_angle(lng, lat)","category":"page"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"Additionally, the function can be called directly on a grid","category":"page"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"using .ExESS\ngrid = Struct_2D_sGrid(180, 45)\nsolar_anlge(grid) # == solar_angle.(grid.lngs, grid.lats)","category":"page"},{"location":"surfaces/solar_angle.html#Examples","page":"Solar Angles","title":"Examples","text":"","category":"section"},{"location":"surfaces/solar_angle.html#API","page":"Solar Angles","title":"API","text":"","category":"section"},{"location":"surfaces/solar_angle.html","page":"Solar Angles","title":"Solar Angles","text":"solar_angle","category":"page"},{"location":"surfaces/solar_angle.html#Main.ExESS.solar_angle","page":"Solar Angles","title":"Main.ExESS.solar_angle","text":"[1] solar_angle(lng::Real, lat::Real)::Float32\n[2] solar_angle(xs::SphericalPosition)::Float32\n[3] solar_angle(grid::AbstractGrid)::Vector{Float32}\n\nCalculate the solar incidence angle based in selenocentric coordinates given as lng and lat in radians. Providing a grid as the input argument automatically extracts the angular coordinates and returns all solar angles as a vector.\n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#Coordinate-Systems","page":"Coordinate Systems","title":"Coordinate Systems","text":"","category":"section"},{"location":"base/coordinate_systems.html","page":"Coordinate Systems","title":"Coordinate Systems","text":"Currently there are two different custom position and three velocity types implemented, based on a total of three coordinate systems (CS):","category":"page"},{"location":"base/coordinate_systems.html","page":"Coordinate Systems","title":"Coordinate Systems","text":"fixed, cartesian coordinate system (CCS, subscript \"c\")\nfixed, spherical coordinate system (SCS, subscript \"s\")\nrotating (local) cartesian (spherical) coordinate system (CSCS, subscript \"cs\")","category":"page"},{"location":"base/coordinate_systems.html#API","page":"Coordinate Systems","title":"API","text":"","category":"section"},{"location":"base/coordinate_systems.html","page":"Coordinate Systems","title":"Coordinate Systems","text":"CartesianPosition\nCartesianSphericalVelocity\nCartesianVelocity\nSphericalPosition\nSphericalVelocity","category":"page"},{"location":"base/coordinate_systems.html#Main.ExESS.CartesianPosition","page":"Coordinate Systems","title":"Main.ExESS.CartesianPosition","text":"[1] CartesianPosition(x::Real, y::Real, z::Real)\n[2] CartesianPosition(X::Vector{<:Real})\n[3] CartesianPosition(xs::SphericalPosition)\n\nDefines a three dimensional, fixed, cartesian position vector. The vector can be created based on positional or vectorial input for x, y, and z, or using a positional vector in another coordinate system like SphericalPosition, which automatically converts the vector into cartesian coordinates.\n\nFields\n\nx: x position\ny: y position\nz: z position\n\nConversions\n\nLet vecx_c be of type CartesianPosition and vecx_s of type SphericalPosition:\n\nvecx_c = beginbmatrix x  y  z  endbmatrix qquad\nvecx_s = beginbmatrix R  theta  phi  endbmatrix qquad\nvecx_c left( vecx_s right) = beginbmatrix\n    R cdot costheta cdot cosphi \n    R cdot sintheta cdot cosphi \n    R cdot sinphi\nendbmatrix\n\n\n\n\n\n","category":"type"},{"location":"base/coordinate_systems.html#Main.ExESS.CartesianSphericalVelocity","page":"Coordinate Systems","title":"Main.ExESS.CartesianSphericalVelocity","text":"[1] CartesianSphericalVelocity(x::Real, y::Real, z::Real)\n[2] CartesianSphericalVelocity(V::Vector{<:Real})\n[3] CartesianSphericalVelocity(xc::CartesianPosition, vc::CartesianVelocity)\n[4] CartesianSphericalVelocity(xs::SphericalPosition, vc::CartesianVelocity)\n[5] CartesianSphericalVelocity(xc::CartesianPosition, vs::SphericalVelocity)\n[6] CartesianSphericalVelocity(xs::SphericalPosition, vs::SphericalVelocity)\n\nThree dimensional velocity vector in a local cartesian coordinate system along spherical directions. The x-axis points along the radial position, based on the respective body's center. The y-axis points towards positive longitude and the z-axis towards positive latitude.\n\nThe velocity vector can be created through direct input for x, y, and z, or \n\nBenchmark Notes\n\nt_4 approx 7 times t_3\nt_5 approx 7 times t_3\n\n\n\n\n\n","category":"type"},{"location":"base/coordinate_systems.html#Main.ExESS.CartesianVelocity","page":"Coordinate Systems","title":"Main.ExESS.CartesianVelocity","text":"[1] CartesianVelocity(x::Real, y::Real, z::Real)\n[2] CartesianVelocity(V::Vector{<:Real})\n[3] CartesianVelocity(xc::CartesianPosition, vcs::CartesianSphericalVelocity)\n[4] CartesianVelocity(xs::SphericalPosition, vcs::SphericalVelocity)\n[5] CartesianVelocity(xc::CartesianPosition, vs::CartesianSphericalVelocity)\n[6] CartesianVelocity(xs::SphericalPosition, vs::SphericalVelocity)\n\n\n\n\n\n","category":"type"},{"location":"base/coordinate_systems.html#Main.ExESS.SphericalPosition","page":"Coordinate Systems","title":"Main.ExESS.SphericalPosition","text":"[1] SphericalPosition(r::Real, theta::Real, phi::Real)\n[2] SphericalPosition(X::Vector{<:Real})\n[3] SphericalPosition(xc::CartesianPosition)\n\n\n\n\n\n","category":"type"},{"location":"base/coordinate_systems.html#Main.ExESS.SphericalVelocity","page":"Coordinate Systems","title":"Main.ExESS.SphericalVelocity","text":"[1] SphericalVelocity(r::Real, theta::Real, phi::Real)\n[2] SphericalVelocity(V::Vector{<:Real})\n[3] SphericalVelocity(xc::CartesianPosition, vc::CartesianVelocity)\n[4] SphericalVelocity(xs::SphericalPosition, vc::CartesianVelocity)\n[5] SphericalVelocity(xc::CartesianPosition, vcs::CartesianSphericalVelocity)\n[6] SphericalVelocity(xs::SphericalPosition, vcs::CartesianSphericalVelocity)\n\n\n\n\n\n","category":"type"},{"location":"base/coordinate_systems.html#Base-Extensions","page":"Coordinate Systems","title":"Base Extensions","text":"","category":"section"},{"location":"base/coordinate_systems.html","page":"Coordinate Systems","title":"Coordinate Systems","text":"+\n-\n*\nget\nisapprox\nisequal","category":"page"},{"location":"base/coordinate_systems.html#Base.:+","page":"Coordinate Systems","title":"Base.:+","text":"[1] Base.:+(xc1::CartesianPosition, xc2::CartesianPosition)::CartesianPosition\n[2] Base.:+(xc::CartesianPosition, xs::SphericalPosition)::CartesianPosition\n[3] Base.:+(xc::CartesianPosition, x::Vector{<:Real})::CartesianPosition\n[4] Base.:+(xs1::SphericalPosition, xs2::SphericalPosition)::SphericalPosition\n[5] Base.:+(xs::SphericalPosition, xc::CartesianPosition)::SphericalPosition\n[6] Base.:+(xs::SphericalPosition, x::Vector{<:Real})::SphericalPosition\n[7] Base.:+(vc1::CartesianVelocity, vc2::CartesianVelocity)::CartesianVelocity\n[8] Base.:+(vc::CartesianVelocity, v::Vector{<:Real})::CartesianVelocity\n\nBase extension to add simple addition of custom position and velocity vectors. Output type is equal to the first input type with the second variable being converted into the correct format.\n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#Base.:-","page":"Coordinate Systems","title":"Base.:-","text":"[1] Base.:-(xc1::CartesianPosition, xc2::CartesianPosition)::CartesianPosition\n[2] Base.:-(xc::CartesianPosition, x::Vector{<:Real})::CartesianPosition\n[3] Base.:-(xc::CartesianPosition, x::Vector{<:Real})::CartesianPosition\n[4] Base.:-(xs1::SphericalPosition, xs2::SphericalPosition)::SphericalPosition\n[5] Base.:-(xs::SphericalPosition, xc::CartesianPosition)::SphericalPosition\n[6] Base.:-(xs::SphericalPosition, x::Vector{<:Real})::SphericalPosition\n[7] Base.:-(vc1::CartesianVelocity, vc2::CartesianVelocity)::CartesianVelocity\n[8] Base.:-(vc::CartesianVelocity, v::Vector{<:Real})::CartesianVelocity\n\nBase extension to add simple subtraction of custom position and velocity vectors. Output type is equal to the first input type with the second variable being converted into the correct format.\n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#Base.:*","page":"Coordinate Systems","title":"Base.:*","text":"[1] Base.:*(xc1::CartesianPosition, xc2::CartesianPosition)::Float32\n[2] Base.:*(xc::CartesianPosition, x::Vector{<:Real})::Float32\n[3] Base.:*(x::Vector{<:Real}, xc::CartesianPosition)::Float32\n[4] Base.:*(xc::CartesianPosition, a::Real)::CartesianPosition\n[5] Base.:*(a::Real, xc::CartesianPosition)::CartesianPosition\n[6] Base.:*(xs1::SphericalPosition, xs2::SphericalPosition)::Float32\n[7] Base.:*(xc::CartesianPosition, xs::SphericalPosition)::Float32\n[8] Base.:*(xs::SphericalPosition, xc::CartesianPosition)::Float32\n[9] Base.:*(vc1::CartesianVelocity, vc2::CartesianVelocity)::Float32\n[10] Base.:*(vc::CartesianVelocity, v::Vector{<:Real})::Float32\n[11] Base.:*(v::Vector{<:Real}, vc::CartesianVelocity)::Float32\n[12] Base.:*(vc::CartesianVelocity, a::Real)::CartesianVelocity\n[13] Base.:*(a::Real, vc::CartesianVelocity)::CartesianVelocity\n\nBase extension to add multiplication of custom position and velocity vectors. \n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#Base.get","page":"Coordinate Systems","title":"Base.get","text":"[1] Base.get(xc::CartesianPosition)::Vector{Float32}\n[2] Base.get(vcs::CartesianSphericalVelocity)::Vector{Float32}\n[3] Base.get(vc::CartesianVelocity)::Vector{Float32}\n[4] Base.get(xs::SphericalPosition)::Vector{Float32}\n[5] Base.get(vs::SphericalVelocity)::Vector{Float32}\n\nBase extension of the get function used to return the fields of the specialized  vectors in their usual order x y z and r theta phi.\n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#Base.isapprox","page":"Coordinate Systems","title":"Base.isapprox","text":"[1] Base.isapprox(a::T, b::T; rtol=1e-6) where {T<:Union{Position, Velocity}}\n[2] Base.isapprox(xc::CartesianPosition, xs::SphericalPosition; rtol=1e-6)\n[3] Base.isapprox(xs::SphericalPosition, xc::CartesianPosition; rtol=1e-6)\n\nBase extension of the isapprox (or ≈) function to compare specialized vectors. The function can handle two inputs of the same type for all special types as well as a comparison between all positional types interchangingly.\n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#Base.isequal","page":"Coordinate Systems","title":"Base.isequal","text":"[1] Base.isequal(a::T, b::T; rtol=1e-6) where {T<:Union{Position, Velocity}}\n[2] Base.isequal(xc::CartesianPosition, xs::SphericalPosition; rtol=1e-6)\n[3] Base.isequal(xs::SphericalPosition, xc::CartesianPosition; rtol=1e-6)\n\nBase extension of the isequal (or ==) function to compare specialized vectors. The function can handle two inputs of the same type for all special types as well as a comparison between all positional types interchangingly.\n\n\n\n\n\n","category":"function"},{"location":"base/coordinate_systems.html#LinearAlgebra-Extensions","page":"Coordinate Systems","title":"LinearAlgebra Extensions","text":"","category":"section"},{"location":"base/coordinate_systems.html","page":"Coordinate Systems","title":"Coordinate Systems","text":"dot\nnorm","category":"page"},{"location":"base/constants.html#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"base/constants.html","page":"Constants","title":"Constants","text":"The following constants are defined in the base of the ExESS package to be used in the calculations of the implemented physical phenomena.","category":"page"},{"location":"base/constants.html","page":"Constants","title":"Constants","text":"AVOGADRO_CONSTANT\nBOLTZMANN_CONSTANT\nGRAVITATIONAL_CONSTANT\nPLANCK_CONSTANT\nUNIVERSAL_GAS_CONSTANT\nELEMENTARY_CHARGE","category":"page"},{"location":"base/constants.html#Main.ExESS.AVOGADRO_CONSTANT","page":"Constants","title":"Main.ExESS.AVOGADRO_CONSTANT","text":"N_A = 602214086 times 10^23  textmol^-1\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Main.ExESS.BOLTZMANN_CONSTANT","page":"Constants","title":"Main.ExESS.BOLTZMANN_CONSTANT","text":"k_B = 138065 times 10^-23  textJ K^-1\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Main.ExESS.GRAVITATIONAL_CONSTANT","page":"Constants","title":"Main.ExESS.GRAVITATIONAL_CONSTANT","text":"mu = 667408 times 10^-11  textm^3  textkg^-1  texts^-2\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Main.ExESS.PLANCK_CONSTANT","page":"Constants","title":"Main.ExESS.PLANCK_CONSTANT","text":"h = 662607004 times 10^-34  textm^2  textkg  texts^-1\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Main.ExESS.UNIVERSAL_GAS_CONSTANT","page":"Constants","title":"Main.ExESS.UNIVERSAL_GAS_CONSTANT","text":"R = 83144626181532  textJ  textK^-1  textmol^-1\n\n\n\n\n\n","category":"constant"},{"location":"base/constants.html#Main.ExESS.ELEMENTARY_CHARGE","page":"Constants","title":"Main.ExESS.ELEMENTARY_CHARGE","text":"e = 1602176634 times 10^-19  textC\n\n\n\n\n\n","category":"constant"},{"location":"base/utils.html#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"base/utils.html","page":"Utility","title":"Utility","text":"The base of ExESS is complimented with a set of utility functions shown below.","category":"page"},{"location":"base/utils.html#Manual","page":"Utility","title":"Manual","text":"","category":"section"},{"location":"base/utils.html","page":"Utility","title":"Utility","text":"Due to the large order of magnitude in some of the calculations of astronomical quantities, numerical issues like round-off issues can arise. This is especially detrimental for functions with a limited parameter space, like the inverse trigonometric functions for sine and cosine, which are only defined for x in -11. To prevent a program failure, the function limit_acos is implemented to handle input outside of the predefined parameter space for the acos() function","category":"page"},{"location":"base/utils.html","page":"Utility","title":"Utility","text":"limit_acos(x::Real)::Float32 = (abs(x) > 1) ? acos(sign(x)) : acos(x) # hide\n# hide\nacos(-2)\nacos(-1)\nacos(0)\nacos(1)\nacos(2)\n\nlimit_acos(-2)\nlimit_acos(-1)\nlimit_acos(0)\nlimit_acos(1)\nlimit_acos(2)","category":"page"},{"location":"base/utils.html","page":"Utility","title":"Utility","text":"note: Caution\nThe limit_acos function shall be used with caution, as it bypasses the natural domain check of acos(). Make sure that the use of limit_acos is necessary and that the necessity originates from numerical issues, leading only sometimes to input values with an absolute value bigger than one.","category":"page"},{"location":"base/utils.html#API","page":"Utility","title":"API","text":"","category":"section"},{"location":"base/utils.html","page":"Utility","title":"Utility","text":"limit_acos","category":"page"},{"location":"base/utils.html#Main.ExESS.limit_acos","page":"Utility","title":"Main.ExESS.limit_acos","text":"[1] limit_acos(x::Real)::Float32\n\nExtends the acos function for input outside of [-1,1] through clipping.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Orbital-Mechanics","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"","category":"section"},{"location":"exospheres/orbital_mechanics.html","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"The following functions are based on the following two works:","category":"page"},{"location":"exospheres/orbital_mechanics.html","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"Walter, U., 2018. Astronautics, The Physics of Space Flight. 3 ed., Springer Cham.\nN. Schörghofer, User guide, planetary-code-collection: Thermal and ice evolution models for planetary surfaces, 2002-2022","category":"page"},{"location":"exospheres/orbital_mechanics.html","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"The general form of every function in this orbital mechanics library is <output-name>_<input-symbol-1>[_<input-symbol-2>][...]. Thus, there are multiple ways of calculating the desired output.","category":"page"},{"location":"exospheres/orbital_mechanics.html","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"Name Equation(s) Function\nAzimuth angle alpha(textbfv) = cos^-1 left( fracv_2sqrtv_1^2 + v_2^2 right) azimuth_angle_v\nEccentric Anomaly E(e theta) = 2 cdot tan^-1 left( sqrtfrac1-e1+e cdot tanleft(fractheta2right) right) eccentric_anomaly_e_theta\nEccentric Anomaly E_0(e M) = M  E_n+1(e M) = M + e cdot sin E_n eccentric_anomaly_e_M\nEccentricity e(f_2 alpha) = sqrt1 - 4 cdot f_2 cdot (1 - f_2) cdot sin^2alpha  eccentricity_f2_alpha\nEccentricity e(f_2 textbfv) = e(f_2 alpha(textbfv)) eccentricity_f2_v\nEccentricity e(r m textbfv) = e(f_2(r m textbfv) alpha(textbfv)) eccentricity_r_m_v\nEscape velocity v_esc(r m)=sqrtfrac2 cdot G mr escape_velocity_r_m\nSquared v_esc fraction f_2(v_esc textbfv) = left( fractextbfvv_esc right)^2 fvesc2_vesc_v\nSquared v_esc fraction f_2(r m textbfv) = f_2(v_esc(r m) textbfv) fvesc2_r_m_v\nGround distance d(R dtheta) = dtheta cdot R ground_distance_R_dtheta\nGround distance d(R a e) = d(R theta(R a e)) ground_distance_R_a_e\nMean anomaly M(e E) = E - e cdot sin E mean_anomaly_e_E\nMean anomaly M(e theta) = M(e E(e theta)) mean_anomaly_e_theta\nOrbital period P(a m) = 2pi cdot sqrtfraca^3Gm orbit_period_a_m\nOrbit time t(M P) = M cdot fracP2pi orbit_time_M_P\nOrbit time t(e E P) = t(M(e E) P) orbit_time_e_E_P\nOrbit time t(e theta P) = t(e E(e theta) P) orbit_time_e_theta_P\nSemi-latus rectum p(a e) = a cdot (1 - e^2) semi_latus_rectum_a_e\nSemi-latus rectum p(r e theta) = r cdot (1 + e cdot cos theta) semi_latus_rectum_r_e_theta\nSemi-major axis a(r f_2)  = fracr2 cdot (1 - f_2) semi_major_axis_r_f2\nSemi-major axis a(r m textbfv)  = a(r f_2(r m textbfv)) semi_major_axis_r_m_v\nSemi-major axis a(p e) = fracp1 - e^2 semi_major_axis_p_e\nSemi-major axis a(r e theta) = fracr cdot (1 + ecdotcostheta)1 - e^2 semi_major_axis_r_e_theta\nTrue anomaly theta(r a e) = cos^-1 left( frac1e cdot left( fracar cdot (1 - e^2) - 1 right) right) true_anomaly_r_a_e\nTrue anomaly theta(e f_2) = cos^-1 left( frac1e cdot left( frac1 - e^22 - 2 cdot f_2 - 1 right) right) true_anomaly_e_f2\nZenith angle beta(textbfv) = tan^-1 left( fracsqrtv_1^2 + v_2^2v_3 right) zenith_angle_v","category":"page"},{"location":"exospheres/orbital_mechanics.html","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"note: Symbols\nNote that the bold letter textbfv denotes the velocity vector. In these cases the program assumes that the vector is three-dimensional.","category":"page"},{"location":"exospheres/orbital_mechanics.html#API","page":"Orbital Mechanics","title":"API","text":"","category":"section"},{"location":"exospheres/orbital_mechanics.html","page":"Orbital Mechanics","title":"Orbital Mechanics","text":"azimuth_angle_v\n\neccentric_anomaly_e_M\neccentric_anomaly_e_theta\n\neccentricity_f2_alpha \neccentricity_f2_v\neccentricity_r_m_v\n\nescape_velocity_r_m\n\nflight_time_t0_t1\nflight_time_t0_P\nflight_time_e_theta0_theta1_P\nflight_time_e_theta0_P\n\nfvesc2_vesc_v\nfvesc2_r_m_v\nfvesc2_r_a\nfvesc2_e_theta\n\nground_distance_R_dtheta\nground_distance_R_a_e\n\nmean_anomaly_e_E\nmean_anomaly_e_theta\n\norbit_period_a_m\n\norbit_time_M_P\norbit_time_e_E_P\norbit_time_e_theta_P\n\nsemi_latus_rectum_a_e\nsemi_latus_rectum_r_e_theta\n\nsemi_major_axis_r_f2\nsemi_major_axis_r_m_v\nsemi_major_axis_p_e\nsemi_major_axis_r_e_theta\n\ntrue_anomaly_r_a_e\ntrue_anomaly_e_f2\ntrue_anomaly_f2_v\n\nzenith_angle_v","category":"page"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.azimuth_angle_v","page":"Orbital Mechanics","title":"Main.ExESS.azimuth_angle_v","text":"[1] azimuth_angle_v(v::AbstractVector)::Float32\n[2] azimuth_angle_v(v::CartesianSphericalVelocity)::Float32\n\nCalculates the azimuth angle of the launch velocity vector v.\n\n    alpha(textbfv) = cos^-1 left( fracv_2sqrtv_1^2 + v_2^2 right)\n\nalpha: azimuth angle\ntextbfv = left v_1 v_2 v_3 right^T: velocity vector \n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.eccentric_anomaly_e_M","page":"Orbital Mechanics","title":"Main.ExESS.eccentric_anomaly_e_M","text":"[1] eccentric_anomaly_e_M(e::Real, M::Real, N=10)::Float32\n\nCalculates the eccentric anomaly given the orbit's eccentricity e and the mean anomaly M,  which triggers a numerical approximation with N steps.\n\nAlternative Functions\n\neccentric_anomaly_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.eccentric_anomaly_e_theta","page":"Orbital Mechanics","title":"Main.ExESS.eccentric_anomaly_e_theta","text":"[1] eccentric_anomaly_e_theta(e::Real, theta::Real)::Float32\n\nCalculates the eccentric anomaly given the orbit's eccentricity e and the true anomaly theta. The result is normalized to [0,2π).\n\nAlternative Functions\n\neccentric_anomaly_e_M\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.eccentricity_f2_alpha","page":"Orbital Mechanics","title":"Main.ExESS.eccentricity_f2_alpha","text":"[1] eccentricity_f2_alpha(f2::Real, alpha::Real)::Float32\n\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction f2, and the zenith launch angle alpha.\n\nAlternative Functions\n\neccentricity_f2_v\neccentricity_r_m_v\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.eccentricity_f2_v","page":"Orbital Mechanics","title":"Main.ExESS.eccentricity_f2_v","text":"[1] eccentricity_f2_v(f2::Real, v::AbstractVector)::Float32\n[2] eccentricity_f2_v(f2::Real, v::CartesianSphericalVelocity)::Float32\n\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction f2, and the velocity vector v.\n\nAlternative Functions\n\neccentricity_f2_alpha\neccentricity_r_m_v\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.eccentricity_r_m_v","page":"Orbital Mechanics","title":"Main.ExESS.eccentricity_r_m_v","text":"[1] eccentricity_r_m_v(r::Real, m::Real, v::AbstractVector)::Float32\n[2] eccentricity_r_m_v(r::Real, m::Real, v::CartesianSphericalVelocity)::Float32\n\nCalculates the eccentricity of an elliptical trajetory based on the orbital radius r, the body's mass m, and the velocity vector v.\n\nAlternative Functions\n\neccentricity_f2_alpha\neccentricity_f2_v\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.escape_velocity_r_m","page":"Orbital Mechanics","title":"Main.ExESS.escape_velocity_r_m","text":"[1] escape_velocity_r_m(r::Real, m::Real)::Float32\n\nCalculates the magnitude of the escape velocity for an orbital radius r and body mass m.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.flight_time_t0_t1","page":"Orbital Mechanics","title":"Main.ExESS.flight_time_t0_t1","text":"[1] flight_time_t0_t1(t0::Real, t1::Real)::Float32\n\nCalculates the time of flight between the two orbital times t0 and t1.\n\nAlternative Functions\n\nflight_time_t0_P\nflight_time_e_theta0_theta1_P\nflight_time_e_theta0_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.flight_time_t0_P","page":"Orbital Mechanics","title":"Main.ExESS.flight_time_t0_P","text":"[1] flight_time_t0_P(t0::Real, P::Real)::Float32\n\nCalculates the time of flight, given a symmetrical trajectory with a starting orbital time of t0 and a landing orbital time of P-t0, with the orbital period P. \n\nAlternative Functions\n\nflight_time_t0_t1\nflight_time_e_theta0_theta1_P\nflight_time_e_theta0_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.flight_time_e_theta0_theta1_P","page":"Orbital Mechanics","title":"Main.ExESS.flight_time_e_theta0_theta1_P","text":"[1] flight_time_e_theta0_theta1_P(e::Real, theta0::Real, theta1::Real, P::Real)::Float32\n\nCalculates the time of flight between the two orbital positions theta0 and theta1, given the eccentricity e and period P of the orbit.\n\nAlternative Functions\n\nflight_time_t0_t1\nflight_time_t0_P\nflight_time_e_theta0_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.flight_time_e_theta0_P","page":"Orbital Mechanics","title":"Main.ExESS.flight_time_e_theta0_P","text":"[1] flight_time_e_theta0_P(e::Real, theta0::Real, P::Real)::Float32\n\nCalculates the time of flight, given a symmetrical trajectory between the two orbital  positions theta0 and 2π - theta0, given the eccentricity e and period P of the orbit.\n\nAlternative Functions\n\nflight_time_t0_t1\nflight_time_t0_P\nflight_time_e_theta0_theta1_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.fvesc2_vesc_v","page":"Orbital Mechanics","title":"Main.ExESS.fvesc2_vesc_v","text":"[1] fvesc2_vesc_v(vesc::Real, v::AbstractVector)::Float32\n[2] fvesc2_vesc_v(vesc::Real, v::CartesianSphericalVelocity)::Float32\n\nCalculates the squared fraction of the velocity vector v with respect to the escape velocity vesc.\n\nAlternative Functions\n\nfvesc2_r_m_v\nfvesc2_r_a\nfvesc2_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.fvesc2_r_m_v","page":"Orbital Mechanics","title":"Main.ExESS.fvesc2_r_m_v","text":"[1] fvesc2_r_m_v(r::Real, m::Real, v::AbstractVector)::Float32\n[2] fvesc2_r_m_v(r::Real, m::Real, v::CartesianSphericalVelocity)::Float32\n\nCalculates the squared fraction of the velocity vector v, based on the orbital radius  r and the body's mass m.\n\nAlternative Functions\n\nfvesc2_vesc_v\nfvesc2_r_a\nfvesc2_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.fvesc2_r_a","page":"Orbital Mechanics","title":"Main.ExESS.fvesc2_r_a","text":"[1] fvesc2_r_a(r::Real, a::Real)::Float32\n\nCalculates the squared fraction of the velocity at the radial position r on an orbit defined through the semi-major axis a.\n\nAlternative Functions\n\nfvesc2_vesc_v\nfvesc2_r_m_v\nfvesc2_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.fvesc2_e_theta","page":"Orbital Mechanics","title":"Main.ExESS.fvesc2_e_theta","text":"[1] fvesc2_e_theta(e::Real, theta::Real)::Float32\n\nCalculates the squared fraction of the velocity at the angular position theta on an orbit defined through the eccentricity e.\n\nAlternative Functions\n\nfvesc2_vesc_v\nfvesc2_r_m_v\nfvesc2_r_a\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.ground_distance_R_dtheta","page":"Orbital Mechanics","title":"Main.ExESS.ground_distance_R_dtheta","text":"[1] ground_distance_R_dtheta(R::Real, dtheta::Real)::Float32\n\nCalculates the ground flight distance covered by an angle dtheta of an elliptical orbit,  which intersects with a body of radius R.\n\nAlternative Functions\n\nground_distance_R_a_e\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.ground_distance_R_a_e","page":"Orbital Mechanics","title":"Main.ExESS.ground_distance_R_a_e","text":"[1] ground_distance_R_a_e(R::Real, a::Real, e::Real)::Float32\n\nCalculates the ground flight distance covered based on the radius of the body R, the  orbit's semi-major axis a, and the eccentricity e.\n\nAlternative Functions\n\nground_distance_R_dtheta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.mean_anomaly_e_E","page":"Orbital Mechanics","title":"Main.ExESS.mean_anomaly_e_E","text":"[1] mean_anomaly_e_E(e::Real, E::Real)::Float32\n\nCalculates the mean anomaly, given the orbit's eccentricity e and the eccentric anomaly E.\n\nAlternative Functions\n\nmean_anomaly_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.mean_anomaly_e_theta","page":"Orbital Mechanics","title":"Main.ExESS.mean_anomaly_e_theta","text":"[1] mean_anomaly_e_theta(e::Real, theta::Real)::Float32\n\nCalculates the mean anomaly, given the orbit's eccentricity e and the true anomaly theta.\n\nAlternative Functions\n\nmean_anomaly_e_E\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.orbit_period_a_m","page":"Orbital Mechanics","title":"Main.ExESS.orbit_period_a_m","text":"[1] orbit_period_a_m(a::Real, m::Real)::Float32\n\nCalculates the period of an elliptical orbit, based on the semi-major axis a, and the body's mass m.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.orbit_time_M_P","page":"Orbital Mechanics","title":"Main.ExESS.orbit_time_M_P","text":"[1] orbit_time_M_P(M::Real, P::Real)::Float32\n\nCalculates the time at the position of an orbit defined through the mean anomaly M, as  well as the orbital period P.\n\nAlternative Functions\n\norbit_time_e_E_P\norbit_time_e_theta_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.orbit_time_e_E_P","page":"Orbital Mechanics","title":"Main.ExESS.orbit_time_e_E_P","text":"[1] orbit_time_e_E_P(e::Real, E::Real, P::Real)::Float32\n\nCalculates the time at the position of an orbit defined through the eccentric anomaly E,  the eccentricity e, and the orbital period P.\n\nAlternative Functions\n\norbit_time_M_P\norbit_time_e_theta_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.orbit_time_e_theta_P","page":"Orbital Mechanics","title":"Main.ExESS.orbit_time_e_theta_P","text":"[1] orbit_time_e_theta_P(e::Real, theta::Real, P::Real)::Float32\n\nCalculates the time at the position of an orbit defined through the true anomaly theta,  the eccentricity e, and the orbital period P.\n\nAlternative Functions\n\norbit_time_M_P\norbit_time_e_E_P\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.semi_latus_rectum_a_e","page":"Orbital Mechanics","title":"Main.ExESS.semi_latus_rectum_a_e","text":"[1] semi_latus_rectum_a_e(a::Real, e::Real)::Float32\n\nCalculates the semi-latus-rectum of the elliptical trajetory defined through the semi-major axis a and the eccentricity e.\n\nAlternative Functions\n\nsemi_latus_rectum_r_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.semi_latus_rectum_r_e_theta","page":"Orbital Mechanics","title":"Main.ExESS.semi_latus_rectum_r_e_theta","text":"[1] semi_latus_rectum_r_e_theta(r::Real, e::Real, theta::Real)::Float32\n\nCalculates the semi-latus-rectum of the elliptical trajetory based on the orbital radius r, the eccentricity e, and the true anomaly theta\n\nAlternative Functions\n\nsemi_latus_rectum_a_e\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.semi_major_axis_r_f2","page":"Orbital Mechanics","title":"Main.ExESS.semi_major_axis_r_f2","text":"[1] semi_major_axis_r_f2(r::Real, f2::Real)::Float32\n\nCalculates the semi-major axis of an elliptical orbit with the current orbital  radius r and the trajectory's squared escape velocity fraction f2.\n\nAlternative Functions\n\nsemi_major_axis_r_m_v\nsemi_major_axis_p_e\nsemi_major_axis_r_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.semi_major_axis_r_m_v","page":"Orbital Mechanics","title":"Main.ExESS.semi_major_axis_r_m_v","text":"[1] semi_major_axis_r_m_v(r::Real, m::Real, v::AbstractVector)::Float32\n[2] semi_major_axis_r_m_v(r::Real, m::Real, v::CartesianSphericalVelocity)::Float32\n\nCalculates the semi-major axis of an elliptical orbit with the current orbital  radius r, the body's mass m, and the velocity vector v.\n\nAlternative Functions\n\nsemi_major_axis_r_f2\nsemi_major_axis_p_e\nsemi_major_axis_r_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.semi_major_axis_p_e","page":"Orbital Mechanics","title":"Main.ExESS.semi_major_axis_p_e","text":"[1] semi_major_axis_p_e(p::Real, e::Real)::Float32\n\nCalculates the semi-major axis of an elliptical orbit with the semi-latus rectum p and  eccentricity e.\n\nAlternative Functions\n\nsemi_major_axis_r_f2\nsemi_major_axis_r_m_v\nsemi_major_axis_r_e_theta\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.semi_major_axis_r_e_theta","page":"Orbital Mechanics","title":"Main.ExESS.semi_major_axis_r_e_theta","text":"[1] semi_major_axis_r_e_theta(r::Real, e::Real, theta::Real)::Float32\n\nCalculates the semi-major axis of an elliptical orbit with the oribital radius r, the eccentricity e, and the true anomaly theta.\n\nAlternative Functions\n\nsemi_major_axis_r_f2\nsemi_major_axis_r_m_v\nsemi_major_axis_p_e\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.true_anomaly_r_a_e","page":"Orbital Mechanics","title":"Main.ExESS.true_anomaly_r_a_e","text":"[1] true_anomaly_r_a_e(r::Real, a::Real, e::Real)::Float32\n\nCalculates the true anomaly at the radial position r based on the semi-major axis a, and the eccentricity of the orbit e.\n\nAlternative Functions\n\ntrue_anomaly_e_f2\ntrue_anomaly_f2_v\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.true_anomaly_e_f2","page":"Orbital Mechanics","title":"Main.ExESS.true_anomaly_e_f2","text":"[1] true_anomaly_e_f2(e::Real, f2::Real)::Float32\n\nCalculates the true anomaly based on the eccentricity of the orbit e and the current squared escape velocity fraction f2.\n\nAlternative Functions\n\ntrue_anomaly_r_a_e\ntrue_anomaly_f2_v\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.true_anomaly_f2_v","page":"Orbital Mechanics","title":"Main.ExESS.true_anomaly_f2_v","text":"[1] true_anomaly_f2_v(f2::Real, v::AbstractVector)::Float32\n[2] true_anomaly_f2_v(f2::Real, v::CartesianSphericalVelocity)::Float32\n\nCalculates the true anomaly based on the current velocity vector v and the current squared escape velocity fraction f2.\n\nAlternative Functions\n\ntrue_anomaly_r_a_e\ntrue_anomaly_e_f2\n\n\n\n\n\n","category":"function"},{"location":"exospheres/orbital_mechanics.html#Main.ExESS.zenith_angle_v","page":"Orbital Mechanics","title":"Main.ExESS.zenith_angle_v","text":"[1] zenith_angle_v(v::AbstractVector)::Float32\n[2] zenith_angle_v(v::CartesianSphericalVelocity)::Float32\n\nCalculates the zenith launch angle based on the launch velocity vector v.\n\n\n\n\n\n","category":"function"},{"location":"grids/structured.html#Structured-Numerical-Grids","page":"Structured Grids","title":"Structured Numerical Grids","text":"","category":"section"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"The grid with the simplest setup is the structured grid, which looks purely at the two-dimensional projection of the sphere's surface onto a flat surface in angular coordinates (theta phi), which is the longitudinal and latitudinal position on the surface. The entire domain of theta in ( -pi pi ) and phi in ( -pi2 pi2 ) is discretized by N_lng and N_lat elements in either direction. Thus, the total number of grid elements is N = N_lng cdot N_lat. The exact coordinates of the center points are calculated through","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"beginaligned\n    theta_i =  pi cdot left( frac2i-1N_lng - 1 right) textand \n    phi_j =  fracpi2 cdot left( frac2j-1N_lat - 1 right)\nendaligned","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"for 1 leq i leq N_lng longitudes theta_i, and 1 leq j leq N_lat latitudes phi_j.","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"The corresponding area A can be analytically calculated for every grid point as","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"    A = int_theta^theta+Deltatheta int_phi^phi+Deltaphi R^2 cos left( theta right) dtheta dphi","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"which leads to a longitude-independent expression after solving the integrals of","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"    A = Deltatheta cdot R^2 cdot left( sin(phi + 05 Deltaphi) - sin(phi - 05 Deltaphi) right)","category":"page"},{"location":"grids/structured.html#Manual","page":"Structured Grids","title":"Manual","text":"","category":"section"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"# load and use ExESS package\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS\n\n# define grid input\nR = 1_000_000 # sphere radius [m]\nN_lng = 180 # number of grid points along longitude [-]\nN_lat = 90 # number of grid points along latitude [-]\n\n# create structured grid\ngrid = Struct_2D_sGrid(R, N_lng, N_lat)","category":"page"},{"location":"grids/structured.html#Examples","page":"Structured Grids","title":"Examples","text":"","category":"section"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"(Image: )\nFigure 1: Structured Grid. Spherical structured grid, displayed on half a sphere. Right, in cartesian coordinates, left projected onto two dimensions and displayed in angular coordinates.","category":"page"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"The projection clearly shows the structured nature of the grid, with equally spaced points distributed over the entire domain. This simplicity comes with a problem, which is visible in the polar view, where the grid points move closer together the closer they are to the poles. Each ring contains the full N_lng number of grid points, making the pole heavily over-represented in terms of the number of points per surface area.","category":"page"},{"location":"grids/structured.html#API","page":"Structured Grids","title":"API","text":"","category":"section"},{"location":"grids/structured.html","page":"Structured Grids","title":"Structured Grids","text":"Struct_2D_sGrid\nStruct_2D_hsGrid\nStruct_3D_sGrid\nStruct_3D_hsGrid","category":"page"},{"location":"exospheres/trajectory.html#Trajectory","page":"Trajectory","title":"Trajectory","text":"","category":"section"},{"location":"exospheres/trajectory.html#Manual","page":"Trajectory","title":"Manual","text":"","category":"section"},{"location":"exospheres/trajectory.html#Examples","page":"Trajectory","title":"Examples","text":"","category":"section"},{"location":"exospheres/trajectory.html#API","page":"Trajectory","title":"API","text":"","category":"section"},{"location":"exospheres/trajectory.html","page":"Trajectory","title":"Trajectory","text":"trajectory\ntrajectory_lunar_gravity\ngett\ngetvc\ngetvs\ngetxc\ngetxs","category":"page"},{"location":"exospheres/trajectory.html#Main.ExESS.trajectory","page":"Trajectory","title":"Main.ExESS.trajectory","text":"[1] trajectory(x0::CartesianPosition, v0::CartesianVelocity, m::Real, q::Real, ff::Function, terminator::Function, saves=Function[];\n    tspan=(0f0,1f10), reltol=1f-4, abstol=1f-4, alg=Tsit5())::ODESolution\n\nCalculates the three-dimensional trajectory of a particle starting at the cartesian position x0, with a cartesian launch velocity of v0, traversing through a forcefield, provided in function ff, based on the mass m and charge q of the particle. The function terminator defines when to stop the differential equations solver, while the functions in the array saves define additional saving points of the solver.\n\nAdditional information about ff\n\nPlease note that the function ff defines a force field in global cartesian coordinates, as it will be used to calculate the time-dependent acceleration based on Newtonian mechanics.\n\nAdditional information about terminator\n\nThe terminator function has to be user-defined and needs two inputs, the velocity-position-vector u, and the time t. Note that u is a six-dimensional vector with the first three entries being the velocity and the remaining three entries being the position, both in global cartesian coordinates.\n\nSince terminator is used as a ContinuousCallback (see DifferentialEquations.jl) it has to return 0 at the condition at which the solver shall terminate. One example could be\n\nfunction terminator(u,t)\n    if t <= 0; return 1; end\n    if norm(u[4:6]) > LUNAR_RADIUS + 1f7; return 0; end\n    return norm(u[4:6]) - LUNAR_RADIUS \nend\n\nNote that, if the condition norm(u[4:6]) > LUNAR_RADIUS is not satisfied, the function returns differentiable output to improve the root-finding algorithms.\n\nAdditional information about saves\n\nThe last and optional entry saves provides a user-defined number of additional conditions, at which the solver is saving the trajectory's position and time. In order to improve the numerical efficiency, please define the functions with differentiable output (see above).\n\nSpecialized functions\n\ntrajectory_lunar_gravity(x0::CartesianPosition, v0::CartesianVelocity; reltol=1f-2, alg=Tsit5())::ODESolution\n\n\n\n\n\n","category":"function"},{"location":"exospheres/trajectory.html#Main.ExESS.trajectory_lunar_gravity","page":"Trajectory","title":"Main.ExESS.trajectory_lunar_gravity","text":"[1] trajectory_lunar_gravity(x0::CartesianPosition, v0::CartesianVelocity; reltol=1f-3)::ODESolution\n\nSpecialized version of the trajectory function to apply only for the calculation of trajectories on the Moon under the sole influence of its graviational well.\n\nThe solver automatically saves additional timesteps at the transition from Sun to shadow, and vice-versa.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/trajectory.html#Main.ExESS.gett","page":"Trajectory","title":"Main.ExESS.gett","text":"[1] gett(traj::ODESolution, idx::Integer)::Float32\n[2] gettall(traj::ODESolution)::Vector{Float32}\n\nReturns the time of the ODESolution object, the trajectory traj, at the solution index idx, or at all saved time stamps.\n\n\n\n\n\n","category":"function"},{"location":"exospheres/trajectory.html#Main.ExESS.getvc","page":"Trajectory","title":"Main.ExESS.getvc","text":"[1] getvc(traj::ODESolution, idx::Integer)::CartesianPosition\n[2] getvc(traj::ODESolution)::Vector{CartesianPosition}\n\nReturns the cartesian velocity of the ODESolution object, the trajectory traj, at the  solution index idx, or at all saved time stamps. \n\n\n\n\n\n","category":"function"},{"location":"exospheres/trajectory.html#Main.ExESS.getvs","page":"Trajectory","title":"Main.ExESS.getvs","text":"[1] getvs(traj::ODESolution, idx::Integer)::SphericalVelocity\n[2] getvs(traj::ODESolution)::Vector{SphericalVelocity}\n\nReturns the cartesian velocity of the ODESolution object, the trajectory traj, at the  solution index idx, or at all saved time stamps. \n\n\n\n\n\n","category":"function"},{"location":"exospheres/trajectory.html#Main.ExESS.getxc","page":"Trajectory","title":"Main.ExESS.getxc","text":"[1] getxc(traj::ODESolution, idx::Integer)::CartesianPosition\n[2] getxc(traj::ODESolution)::Vector{CartesianPosition}\n\nReturns the cartesian position of the ODESolution object, the trajectory traj, at the  solution index idx, or at all saved time stamps. \n\n\n\n\n\n","category":"function"},{"location":"exospheres/trajectory.html#Main.ExESS.getxs","page":"Trajectory","title":"Main.ExESS.getxs","text":"[1] getxs(traj::ODESolution, idx::Integer)::SphericalPosition\n[2] getxs(traj::ODESolution)::Vector{SphericalPosition}\n\nReturns the spherical position of the ODESolution object, the trajectory traj, at the  solution index idx, or at all saved time stamps. \n\n\n\n\n\n","category":"function"},{"location":"grids/fspiral.html#Fibonacci-Spiral-Based-Numerical-Grid","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Based Numerical Grid","text":"","category":"section"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"Points on a spherical surface mathbbS^2 which form a path in form of a spiral can be expressed in spherical coordinates of the form","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"    theta=Lphi qquad 0 leq phi leq pi","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"with the polar angle phi and the azimuth theta, or the latitude and longitude, respectively (Hardin et al., 2016). The factor L gives the slope of the spiral. One generation method of N points defines the two spherical coordinates as","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"beginaligned\n    L =  sqrtNpi \n    h_k =  1 -frac2k-1N  \n    phi_k =  cos^-1(h_k) \n    theta_k =  Lphi_k \nendaligned","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"for k = 1dots N, where the slope L is chosen in order to equalize the distance between adjacent points on the same level of the spiral and points on adjacent levels which differ by 2pi in theta (Hardin et al., 2016).","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"A specialized method of creating a set of spiral points implements the Fibonacci sequence","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"    left F_k right = left1 1 2 3 5 8 13 dots right","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"and the golden ratio varphi = frac1 + sqrt52 The general algorithm defines a lattice of points on the square left 01 right)^2, which is subsequently mapped to a unit sphere using the Lambert cylindrical equal area projection Lambda:","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"    Lambda(xy) = left( sqrt1-(2y-1)^2cdotcosleft(2pi xright) sqrt1-(2y-1)^2cdotsinleft(2pi xright) 2y-1 right)","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"in Cartesian coordinates, and","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"    Lambda(xy) = left(cos^-1(2y-1) 2pi x right) = left( phi theta right)","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"in spherical coordinates. The points (x y) on the square left 01 right)^2 are created through","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"    (tilde x y)_F_k = left( fraciF_k-1F_k  fraciF_k right) qquad 0 leq i leq F_k","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"where x = tilde x - lfloor tilde x rfloor as just the fractional part of tilde x (Hardin et al., 2016). While this implementation can only be applied for N+1 elements, where N in  F_k , a more general approach involves the golden ratio varphi. Based on Binet's formula the calculation of (x y) can be changed to","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"    (tilde x y)_N = left( fracivarphi fraciN right) qquad 0 leq i leq N","category":"page"},{"location":"grids/fspiral.html#Manual","page":"Fibonacci Spiral Grids","title":"Manual","text":"","category":"section"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"# load and use ExESS package\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS\n\n# define grid input\nR = 1_000_000 # sphere radius [m]\nN = 1_000 # number of grid points on the sphere [-]\n\n# create structured grid\ngrid = FSpiral_2D_sGrid(R, N)","category":"page"},{"location":"grids/fspiral.html#Examples","page":"Fibonacci Spiral Grids","title":"Examples","text":"","category":"section"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"(Image: )\nFigure 1: Fibonacci sprial based grid. Spherical Fibonacci spiral based grid, displayed on half a sphere. Right, in cartesian coordinates, left projected onto two dimensions and displayed in angular coordinates.","category":"page"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"Almost all points have equal distances to one another. Numerical analyses of the Fibonacci-based spiral sequence omega_N in Hardin et al. (2016) found minimal separations to appear at the poles with value x_1 - x_4  x_iinomega_N and maximum hole in the lattice to occurs in the triangle (x_2 x_3 x_5). ","category":"page"},{"location":"grids/fspiral.html#API","page":"Fibonacci Spiral Grids","title":"API","text":"","category":"section"},{"location":"grids/fspiral.html","page":"Fibonacci Spiral Grids","title":"Fibonacci Spiral Grids","text":"FSpiral_2D_sGrid","category":"page"},{"location":"grids/healpix.html#HEALPix-Numerical-Grid","page":"HEALPix Grids","title":"HEALPix Numerical Grid","text":"","category":"section"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"HEALPix, Hierarchical Equal Area iso-Latitude Pixelization (Hardin et al., 2016), was developed by NASA to have three distinct properties, which are that","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"the sphere is hierarchically tessellated into curvilinear quadrilaterals,\nthe pixelization is an equal area partition of mathbbS^2, and\nthe point sets are distributed along fixed lines of latitude.","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"The generation of such points firstly requires a division of the sphere into twelve equal area, four sided pixels defined by:","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"beginaligned\n    cosphifrac23 qquad theta=mfracpi2 qquad  quad m = 0123 \n    cosphi = frac-2-4m3 + frac8theta3pi qquad fracmpi2 leq theta leq frac(m+1)pi2 qquad  quad m=0123 \n    cosphi=frac2-4m3-frac8theta3pi qquad frac-(m+1)pi2 leq theta leq frac-mpi2 qquad  quad  m=0123\nendaligned","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"These pixels can be further partitioned into a k times k grid of sub-pixels of the same shape and area. The points of the set are located in the centers of each pixel. The subdivision leads to k iso-latitudinal rings at the polar region cosphi23, with","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"    cosphi_i=1-fraci^23k^2 qquad theta_j=fracpi2i left( j - frac12 right)","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"thus, every i-th ring has 4i equally spaced points. Closer to the equatorial region, 2k-1 iso-latitudinal rings with 4k points each emerge. These points are indexed by k leq i leq 2k and 1 leq j leq 4k:","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"    cosphi_i = frac43 - frac2i3k qquad theta_j = fracpi2k left( j - fracs2 right) qquad s = (i-k+1) mod 2","category":"page"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"The last index, s, describes the phase shift between the rings. Finally, this configuration produces a set of N=12k^2 points (Hardin et al., 2016).","category":"page"},{"location":"grids/healpix.html#Manual","page":"HEALPix Grids","title":"Manual","text":"","category":"section"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"# load and use ExESS package\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS\n\n# define grid input\nR = 1_000_000 # sphere radius [m]\nk = 12 # N = 12*k^2 total number of grid points [-]\n\n# create structured grid\ngrid = HEALPix_2D_sGrid(R, k)","category":"page"},{"location":"grids/healpix.html#Examples","page":"HEALPix Grids","title":"Examples","text":"","category":"section"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"(Image: )\nFigure 1: HEALPix based grid. Spherical HEALPix based grid, displayed on half a sphere. Right, in cartesian coordinates, left projected onto two dimensions and displayed in angular coordinates.","category":"page"},{"location":"grids/healpix.html#API","page":"HEALPix Grids","title":"API","text":"","category":"section"},{"location":"grids/healpix.html","page":"HEALPix Grids","title":"HEALPix Grids","text":"HEALPix_2D_sGrid","category":"page"},{"location":"index.html#Extraterrestrial-Exospheres-and-Surfaces-Simulations","page":"Home","title":"Extraterrestrial Exospheres and Surfaces Simulations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For the best UX, please set the documentation theme to light, since all images are optimized for a white background.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This simulation tool was created as a custom package for the computer language Julia. Please refer to the official guide to install Julia on your machine.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To be able to use the ExESS package, the entire repository has to be downloaded from LRZ-GitLab. Afterwards, the code can be used in a number of different ways. The entire module can be included directly by specifying the path of the downloaded package in the include call.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"include(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS","category":"page"},{"location":"index.html#API","page":"Home","title":"API","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ExESS","category":"page"},{"location":"index.html#ExESS","page":"Home","title":"ExESS","text":"ExESS\n\n\n\n\n\n","category":"module"},{"location":"index.html#Author-Information","page":"Home","title":"Author Information","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Alexander Smolka - alexander.smolka@tum.de","category":"page"},{"location":"base/velocity_distributions.html#Velocity-Distributions","page":"Velocity Distributions","title":"Velocity Distributions","text":"","category":"section"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"ExESS has build-in energy and velocity distributions that are used to draw random velocities for various processes.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"For further information, please refer to Smolka (2022).","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"A total of two different velocity distributions are implemented, the Maxwell-Boltzmann and the Maxwell-Boltzmann Flux distribution. Both are used to randomly draw a velocity vector based on the thermal energy available to a particle of a certain mass. In one-dimensional form, the former can be expressed as","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"f(v) = sqrtfracm2 pi k_B T exp left( - fracm v^22 k_B T right)","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"which is directly related to a Gaussian distribution with mean zero and variance frack_B Tm Crider and Vondrak (2002). The extension to three dimensions is the product of all three normal distributions f(v_x v_y v_z) = f(v_x) f(v_y) f(v_z), leading to velocity components that can be directly drawn from a scaled up normal distribution ","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"v_i = sqrtfrack_BTm cdot mathcalN(0 1)","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"The latter distribution assumes that the velocities are drawn from the appropriate flux expression","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"F = rho_0 left( fracm2 pi k_B T right) ^32 int_0^infty int_vartheta=0^pi  2 int_phi=0^2 pi v^2 exp left( - fracm v^22 k_B T right) left( v cos vartheta right) sin vartheta  dvartheta  dvarphi  dv","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"which, integrated twice over both angular coordinates, leads to the simplified expression","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"F = rho_0 left( fracm2 pi k_B T right) ^32 pi int_0^infty v^3 exp left( - fracm v^22 k_B T right) dv","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"The velocity can now be drawn numerically, based on the mapping of three pseudo-random numbers r_1 r_2 r_3 in 01).","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"r_1 = fracint_0^v v^3 exp left( - fracm v^22 k_B T right)  dvint_0^infty v^3 exp left( - fracm v^22 k_B T right)  dv","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"for the magnitude, r_2 = cos^2 theta for the attitude angle, and r_3 = fracphi2pi for the azimuth Brinkmann (1970).","category":"page"},{"location":"base/velocity_distributions.html#Manual","page":"Velocity Distributions","title":"Manual","text":"","category":"section"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"maxwellvdist and mbfluxvdist return the distributions as functions that can be used to draw random velocity vectors. This comes with the advantage that the distribution has to be called only once, while the drawing of the velocities can occur multiple times, based on the same distribution. ","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"# load and use ExESS package\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS\n\n# create velocity distributions, using Helium (4) particles\nf_max = maxwellvdist(4)\nf_mbf = mbfluxvdist(4)\n\n# draw from velocity distributions, using a thermal energy according to a temperature of 250K\nv_max = f_max(250)\nv_mbf = f_mbf(250)","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"Note that both f_max and f_mbf are specialized for a certain atomic mass unit, in this case having the value 4, which stands for the weight of the particle for which the velocity is drawn. They are not specialized for the temperature, which is supplied only when the actual velocities are drawn from the functions.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"The function mbfluxvdist comes with two additional keyword arguments, namely N and atol, which control the numerical creation of the distribution. The former stands for the number of sample points made in the probability space left01right), in between which the distribution is linearly interpolating, while the latter stands for the absolute tolerance used during the mapping at each of the N sample points to the corresponding velocity magnitude. Adjusting the two factors has the following influence on the distribution:","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"Increasing N Decreasing atol\nhigher computational effort higher computational effort\nmore accurate linear interpolation more accurate calculation at sample points\nhigher maximum velocity ","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"The last influence listed under Increasing N is because theoretically, the velocity magnitude corresponding to the sample point of 1 is infinity. Thus, the samples are created as","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"samples = range(0, 1-1/N, N)","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"which means that the upper limit of the vector is approaching 1 with an increasing number of sample points.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"If the user needs a different velocity distribution, a custom function can be built, which returns the new distribution as a function that randomly draws from it. A template is given below:","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"function my_custom_velocity_distribution(amu::Real; key=value)::Function\n    # computations for equal `amu` values\n    # ...\n\n    function f_vdist(T::Real; key=value)::Vector{Float32}\n        # computations for equal `T` values\n        # ...\n    end\n\n    # returns distribution as a function that draws random velocity vectors\n    return f_vdist\nend","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"To verify that the custom distribution is correctly set up, it can be tested using isvdist, which returns true for a correct distribution and false for an incorrect one.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"# correct velocity distributions\nisvdist(f_max)  # true \nisvdist(f_mbf)  # true\n\n# incorrect velocity distributions\nisvdist(x -> [1,2,3])   # false\nisvdist(x -> x)         # false\n# ...","category":"page"},{"location":"base/velocity_distributions.html#Examples","page":"Velocity Distributions","title":"Examples","text":"","category":"section"},{"location":"base/velocity_distributions.html#Normalized-PDF-and-CDF","page":"Velocity Distributions","title":"Normalized PDF & CDF","text":"","category":"section"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"The following shows the PDF and CDF of the two implemented distributions with the corresponding Julia script to create the data shown in the two figures.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"(Image: )\nFigure 1: Normalized PDF Shows the probability densities for both a Maxwellian and a Maxwell-Boltzmann flux velocity distribution. The latter one peaks slightly later at higher velocities.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"(Image: )\nFigure 2: Normalized CDF Shows the cumulative probability densities for both a Maxwellian and a Maxwell-Boltzmann flux velocity distribution.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"# variables\nN = 10_000_000  # number of samples\nB = 100         # number of bins\nu = 1           # atomic mass unit (placeholder)\nT = 100         # temperature (placeholder)\n\n# create distributions\nf_max = ExESS.maxwellvdist(u)\nf_mbf = ExESS.mbfluxvdist(u)\n\n# sample distributions\nusing LinearAlgebra\nvmax = [norm(f_max(T)) for _ in 1:N]\nvmbf = [norm(f_mbf(T)) for _ in 1:N]\n\n# create bins\nbins = range(0, max(vcat(vmax, vmbf)...)*1.001, B+1)\n\n# bin data\nvmax_binned, vmbf_binned = zeros(B), zeros(B)\nfor i in 1:N\n    # maxwellian\n    for j in 1:B\n        vmax[i] < bins[j+1] ? (vmax_binned[j] += 1) : continue\n        break;\n    end\n    # maxwell-boltzmann flux\n    for j in 1:B\n        vmbf[i] < bins[j+1] ? (vmbf_binned[j] += 1) : continue\n        break;\n    end\nend\n\n# normalize probabilities\nvmax_binned = vmax_binned ./ N ./ (bins[2] - bins[1]) .* 100\nvmbf_binned = vmbf_binned ./ N ./ (bins[2] - bins[1]) .* 100\n\n# calculate thermal velocity for normalization\nvT = sqrt(BOLTZMANN_CONSTANT * T / (u / AVOGADRO_CONSTANT * 1e-3))\n\n# save data\nusing DelimitedFiles\nHEADER = [\"bins\" \"max\" \"mbf\"]\nPDF = vcat(HEADER, hcat(bins[1:end-1] ./ vT, vmax_binned, vmbf_binned))\nCDF = vcat(HEADER, hcat(bins[1:end-1] ./ vT, accumulate(+, vmax_binned .* (bins[2]-bins[1])), accumulate(+, vmbf_binned .* (bins[2]-bins[1]))))\nwritedlm(joinpath(@__DIR__, \"norm_pdf.csv\"), PDF, '\\t')\nwritedlm(joinpath(@__DIR__, \"norm_cdf.csv\"), CDF, '\\t')","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"Assuming that the ExESS package is already included and loaded, the above script produces the data for both the PDF and CDF and stores them in .csv file, ready for plotting. Firstly, the necessary variables are created, where both the atomic mass unit u and the temperature T are only placeholders. Both variables are required for the calculations, though they are ultimately used to calculate the thermal velocity vT which normalizes the data, making the choice for u and T irrelevant for the presented visualization.","category":"page"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"After the creation of the distribution, a total number of N samples are drawn from each one and the magnitude is calculated using LinearAlgebra's norm() function. Afterward, the samples are binned into B bins of equal size, and the resulting counts are normalized based on the total number of samples N, the bin size bins[2]-bins[1], and the conversion to percent 100. Using ExESS constants BOLTZMANN_CONSTANT and AVOGADRO_CONSTANT the thermal velocity is calculated to also normalize the bins. The last step loads DelimitedFiles to write the .csv files based on the normalized probabilities.","category":"page"},{"location":"base/velocity_distributions.html#Benchmark","page":"Velocity Distributions","title":"Benchmark","text":"","category":"section"},{"location":"base/velocity_distributions.html#API","page":"Velocity Distributions","title":"API","text":"","category":"section"},{"location":"base/velocity_distributions.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"isvdist\nmbfluxvdist\nmaxwellvdist","category":"page"},{"location":"base/velocity_distributions.html#Main.ExESS.isvdist","page":"Velocity Distributions","title":"Main.ExESS.isvdist","text":"[1] isvdist(f::Function)::Bool\n\nChecks if the function f can be used as a velocity distribution function.\n\n\n\n\n\n","category":"function"},{"location":"base/velocity_distributions.html#Main.ExESS.mbfluxvdist","page":"Velocity Distributions","title":"Main.ExESS.mbfluxvdist","text":"[1] mbfluxvdist(amu::Real; N=100_000, atol=1e-1)::Function\n\nCreates a function that draws a three-dimensional velocity vector from a Maxwell-Boltzmann flux velocity distribution, based on the thermal energy defined through the temperature T.\n\n\n\n\n\n","category":"function"},{"location":"base/velocity_distributions.html#Main.ExESS.maxwellvdist","page":"Velocity Distributions","title":"Main.ExESS.maxwellvdist","text":"[1] maxwellvdist(amu::Real)::Function\n\nCreates a function that draws a three-dimensional velocity vector from a Maxwellian velocity distribution, based on the thermal energy defined through the temperature T.\n\n\n\n\n\n","category":"function"}]
}
